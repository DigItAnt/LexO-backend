/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package it.cnr.ilc.lexo.sparql;

/**
 *
 * @author andreabellandi
 */
public class SparqlGraphViz {

    public static final String GRAPH_VIZ_SENSE_SUMMARY
            = SparqlPrefix.RDFS.getSparqlPrefix() + "\n"
            + SparqlPrefix.INST.getSparqlPrefix() + "\n"
            + SparqlPrefix.ONTOLEX.getSparqlPrefix() + "\n"
            + SparqlPrefix.SKOS.getSparqlPrefix() + "\n"
            + SparqlPrefix.LEXINFO.getSparqlPrefix() + "\n"
            + SparqlPrefix.LUC.getSparqlPrefix() + "\n"
            + "SELECT"
            + " ?" + SparqlVariable.LEXICAL_ENTRY
            + " ?" + SparqlVariable.SENSE_DEFINITION
            + " ?" + SparqlVariable.LEXICAL_ENTRY_POS
            + " ?" + SparqlVariable.LABEL
            + " ?" + SparqlVariable.SENSE
            + "\n"
            + "WHERE { \n"
            + "    ?search a inst:" + SparqlVariable.LEXICAL_SENSE_INDEX + " ;\n"
            + "      luc:query \"lexicalSenseIRI:[IRI]\" ;\n"
            + "      luc:entities ?" + SparqlVariable.SENSE + " .\n"
            + "    ?" + SparqlVariable.SENSE + " skos:definition ?" + SparqlVariable.SENSE_DEFINITION + " ; \n"
            + "        ontolex:isSenseOf ?" + SparqlVariable.LEXICAL_ENTRY + " .\n"
            + "    ?" + SparqlVariable.LEXICAL_ENTRY + " lexinfo:partOfSpeech ?" + SparqlVariable.LEXICAL_ENTRY_POS + " ;\n"
            + "        rdfs:label ?" + SparqlVariable.LABEL + " .\n"
            + "} ";

    public static final String GRAPH_VIZ_SENSE_LINKS
            = SparqlPrefix.INST.getSparqlPrefix() + "\n"
            + SparqlPrefix.ONTO.getSparqlPrefix() + "\n"
            + SparqlPrefix.LUC.getSparqlPrefix() + "\n"
            + SparqlPrefix.LEX.getSparqlPrefix() + "\n"
            + SparqlPrefix.LEXINFO.getSparqlPrefix() + "\n"
            + SparqlPrefix.SKOS.getSparqlPrefix() + "\n"
            + SparqlPrefix.ONTOLEX.getSparqlPrefix() + "\n"
            + SparqlPrefix.RDFS.getSparqlPrefix() + "\n"
            + "SELECT ?" + SparqlVariable.GRAPH + " \n"
            + "(GROUP_CONCAT(concat(strafter(str(?inhypernym),str(lex:)),\":\",?inhypernymWr);SEPARATOR=\";\") AS ?in" + SparqlVariable.HYPERNYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?outhypernym),str(lex:)),\":\",?outhypernymWr);SEPARATOR=\";\") AS ?out" + SparqlVariable.HYPERNYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?inhyponym),str(lex:)),\":\",?inhyponymWr);SEPARATOR=\";\")  AS ?in" + SparqlVariable.HYPONYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?outhyponym),str(lex:)),\":\",?outhyponymWr);SEPARATOR=\";\") AS ?out" + SparqlVariable.HYPONYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?inpartHolonym),str(lex:)),\":\",?inpartHolonymWr);SEPARATOR=\";\") AS ?in" + SparqlVariable.HOLONYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?outpartHolonym),str(lex:)),\":\",?outpartHolonymWr);SEPARATOR=\";\") AS ?out" + SparqlVariable.HOLONYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?inpartMeronym),str(lex:)),\":\",?inpartMeronymWr);SEPARATOR=\";\") AS ?in" + SparqlVariable.MERONYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?outpartMeronym),str(lex:)),\":\",?outpartMeronymWr);SEPARATOR=\";\") AS ?out" + SparqlVariable.MERONYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?outsynonym),str(lex:)),\":\",?outsynonymWr);SEPARATOR=\";\") AS ?out" + SparqlVariable.SYNONYM + "Grouped)\n"
            + "(GROUP_CONCAT(concat(strafter(str(?insynonym),str(lex:)),\":\",?insynonymWr);SEPARATOR=\";\") AS ?in" + SparqlVariable.SYNONYM + "Grouped)\n"
            + "FROM NAMED onto:explicit\n"
            + "FROM NAMED onto:implicit\n"
            + "WHERE {\n"
            + "  ?search a inst:lexicalSenseIndex ;\n"
            + "      luc:query \"lexicalSenseIRI:[IRI]\" ;\n"
            + "      luc:entities ?sense .\n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?sense lexinfo:hypernym ?outhypernym . } \n"
            + "    	?outhypernym ontolex:isSenseOf [ rdfs:label ?outhypernymWr ] \n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?inhypernym lexinfo:hypernym ?sense . } \n"
            + "    	?inhypernym ontolex:isSenseOf [ rdfs:label ?inhypernymWr ] \n"
            + "    }\n"
            + " UNION\n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?sense lexinfo:hyponym ?outhyponym . }\n"
            + "    	?outhyponym ontolex:isSenseOf [ rdfs:label ?outhyponymWr ]\n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?inhyponym lexinfo:hyponym ?sense . } \n"
            + "    	?inhyponym ontolex:isSenseOf [ rdfs:label ?inhyponymWr ]\n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?sense lexinfo:partHolonym ?outpartHolonym . } \n"
            + "    	?outpartHolonym ontolex:isSenseOf [ rdfs:label ?outpartHolonymWr ]\n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?inpartHolonym lexinfo:partHolonym ?sense . } \n"
            + "    	?inpartHolonym ontolex:isSenseOf [ rdfs:label ?inpartHolonymWr ]\n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?sense lexinfo:partMeronym ?outpartMeronym . } \n"
            + "    	?outpartMeronym ontolex:isSenseOf [ rdfs:label ?outpartMeronymWr ]\n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?inpartMeronym lexinfo:partMeronym ?sense . } \n"
            + "    	?inpartMeronym ontolex:isSenseOf [ rdfs:label ?inpartMeronymWr ]\n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?sense lexinfo:synonym ?outsynonym . } \n"
            + "        ?outsynonym ontolex:isSenseOf [ rdfs:label ?outsynonymWr ] \n"
            + "    }\n"
            + " UNION \n"
            + "    { GRAPH ?" + SparqlVariable.GRAPH + " { ?insynonym lexinfo:synonym ?sense . } \n"
            + "    	?insynonym ontolex:isSenseOf [ rdfs:label ?insynonymWr ] \n"
            + "    }\n"
            + "} GROUP BY ?" + SparqlVariable.GRAPH;

//    public static final String OLD__GRAPH_VIZ_NODE_GRAPH
//            // lex:_NODE_ lexinfo:synonym ?target
//            = SparqlPrefix.ONTOLEX.getSparqlPrefix() + "\n"
//            + SparqlPrefix.ONTO.getSparqlPrefix() + "\n"
//            + SparqlPrefix.LEXINFO.getSparqlPrefix() + "\n"
//            + SparqlPrefix.LEX.getSparqlPrefix() + "\n"
//            + SparqlPrefix.SKOS.getSparqlPrefix() + "\n"
//            + SparqlPrefix.RDFS.getSparqlPrefix() + "\n"
//            + "SELECT ?graph ?source ?label ?pos ?def ?labelTarget ?target ?posTarget ?defTarget\n"
//            + "FROM NAMED onto:explicit\n"
//            + "FROM NAMED onto:implicit \n"
//            + "WHERE {\n"
//            + "    GRAPH ?graph { ?source lexinfo:_RELATION_ ?target } .\n"
//            + "    ?source skos:definition ?def .\n"
//            + "    ?le ontolex:sense ?source ;\n"
//            + "        lexinfo:partOfSpeech ?pos ;\n"
//            + "        rdfs:label ?label .\n"
//            + "    ?target skos:definition ?defTarget .\n"
//            + "    ?leTarget ontolex:sense ?target ;\n"
//            + "           lexinfo:partOfSpeech ?posTarget ;\n"
//            + "           rdfs:label ?labelTarget .\n"
//            + "     VALUES (_NODE_VARIABLE_) { (<_NODE_ID_>) }"
//            // + "FILTER(regex(str(_NODE_VARIABLE_), \"http://lexica/mylexicon#_NODE_ID_\"))\n"
//            + "_GRAPH_"
//            + "}";

    public static final String GRAPH_VIZ_NODE_GRAPH
            = "PREFIX path: <http://www.ontotext.com/path#>\n"
            + "PREFIX lexinfo: <http://www.lexinfo.net/ontology/3.0/lexinfo#>\n"
            + "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\n"
            + "PREFIX ontolex: <http://www.w3.org/ns/lemon/ontolex#>\n"
            + "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n"
            + "PREFIX onto: <http://www.ontotext.com/>\n"
            + "SELECT DISTINCT ?graph ?source ?target ?label ?labelTarget ?def ?defTarget ?pos ?posTarget\n"
            + "FROM NAMED onto:explicit\n"
            + "FROM NAMED onto:implicit\n"
            + "WHERE {\n"
            + "    VALUES (?_DIRECTION_ ?property) {\n"
            + "        ( <_NODE_ID_> _RELATION_ )\n"
            + "    }\n"
            + "    SERVICE <http://www.ontotext.com/path#search> {\n"
            + "        <urn:path> path:findPath path:allPaths ;\n"
            + "                   path:sourceNode ?src ;\n"
            + "                   path:destinationNode ?dst ;\n"
            + "                   path:maxPathLength _LENGHT_ ;\n"
            + "                   path:startNode ?source;\n"
            + "                   path:exportBinding ?le ;\n"
            + "                   path:exportBinding ?leTarget ;\n"
            + "                   path:exportBinding ?pos ;\n"
            + "                   path:exportBinding ?graph ;\n"
            + "                   path:exportBinding ?posTarget ;\n"
            + "                   path:endNode ?target .\n"
            + "         SERVICE <urn:path> {\n"
            + "            OPTIONAL { GRAPH ?graph { ?source _RELATION_ ?target } }\n"
            + "            ?source _RELATION_ ?target .\n"
            + "            ?source ontolex:isSenseOf ?le .\n"
            + "            ?le lexinfo:partOfSpeech ?pos .\n"
            + "            ?target ontolex:isSenseOf ?leTarget .\n"
            + "            ?leTarget lexinfo:partOfSpeech ?posTarget .\n"
            + "            \n"
            + "        }\n"
            + "    }\n"
            + "    ?le rdfs:label ?label .\n"
            + "    ?leTarget rdfs:label ?labelTarget .\n"
            + "    ?source skos:definition ?def .\n"
            + "    ?target skos:definition ?defTarget .\n"
            + "} ORDER BY ?graph";

//    public static final String GRAPH_VIZ_NODE_GRAPH_WITH_LENGHT_OUTGOING
//            = SparqlPrefix.PATH.getSparqlPrefix() + "\n"
//            + SparqlPrefix.LEXINFO.getSparqlPrefix() + "\n"
//            + SparqlPrefix.SKOS.getSparqlPrefix() + "\n"
//            + SparqlPrefix.ONTOLEX.getSparqlPrefix() + "\n"
//            + SparqlPrefix.RDFS.getSparqlPrefix() + "\n"
//            + "SELECT DISTINCT ?source ?target ?label ?labelTarget ?def ?defTarget ?pos ?posTarget\n"
//            + "WHERE {\n"
//            + "    VALUES (?src ?property) {\n"
//            + "        ( <_NODE_ID_> _RELATION_ )\n"
//            + "    }\n"
//            + "    SERVICE <http://www.ontotext.com/path#search> {\n"
//            + "        <urn:path> path:findPath path:allPaths ;\n"
//            + "                   path:sourceNode ?src ;\n"
//            + "                   path:destinationNode ?dst ;\n"
//            + "                   path:maxPathLength _PATH_LENGHT_ ;\n"
//            + "                   path:startNode ?source;\n"
//            + "                   path:exportBinding ?le ;\n"
//            + "                   path:exportBinding ?leTarget ;\n"
//            + "                   path:exportBinding ?pos ;\n"
//            + "                   path:exportBinding ?posTarget ;\n"
//            + "                   path:endNode ?target .\n"
//            + "         SERVICE <urn:path> {\n"
//            + "            ?source _RELATION_ ?target .\n"
//            + "            ?source ontolex:isSenseOf ?le .\n"
//            + "            ?le lexinfo:partOfSpeech ?pos .\n"
//            + "            ?target ontolex:isSenseOf ?leTarget .\n"
//            + "            ?leTarget lexinfo:partOfSpeech ?posTarget .\n"
//            + "        }\n"
//            + "    }\n"
//            + "    ?le rdfs:label ?label .\n"
//            + "    ?leTarget rdfs:label ?labelTarget .\n"
//            + "    ?source skos:definition ?def .\n"
//            + "    ?target skos:definition ?defTarget .\n"
//            + "}";
//
//    public static final String GRAPH_VIZ_NODE_GRAPH_WITH_LENGHT_INCOMING
//            = SparqlPrefix.PATH.getSparqlPrefix() + "\n"
//            + SparqlPrefix.LEXINFO.getSparqlPrefix() + "\n"
//            + SparqlPrefix.SKOS.getSparqlPrefix() + "\n"
//            + SparqlPrefix.ONTOLEX.getSparqlPrefix() + "\n"
//            + SparqlPrefix.RDFS.getSparqlPrefix() + "\n"
//            + "SELECT DISTINCT ?source ?target ?label ?labelTarget ?def ?defTarget ?pos ?posTarget\n"
//            + "WHERE {\n"
//            + "    VALUES (?dst ?property) {\n"
//            + "        ( <_NODE_ID_> _RELATION_ )\n"
//            + "    }\n"
//            + "    SERVICE <http://www.ontotext.com/path#search> {\n"
//            + "        <urn:path> path:findPath path:allPaths ;\n"
//            + "                   path:sourceNode ?src ;\n"
//            + "                   path:destinationNode ?dst ;\n"
//            + "                   path:maxPathLength _PATH_LENGHT_ ;\n"
//            + "                   path:startNode ?source;\n"
//            + "                   path:exportBinding ?le ;\n"
//            + "                   path:exportBinding ?leTarget ;\n"
//            + "                   path:exportBinding ?pos ;\n"
//            + "                   path:exportBinding ?posTarget ;\n"
//            + "                   path:endNode ?target .\n"
//            + "         SERVICE <urn:path> {\n"
//            + "            ?source _RELATION_ ?target .\n"
//            + "            ?source ontolex:isSenseOf ?le .\n"
//            + "            ?le lexinfo:partOfSpeech ?pos .\n"
//            + "            ?target ontolex:isSenseOf ?leTarget .\n"
//            + "            ?leTarget lexinfo:partOfSpeech ?posTarget .\n"
//            + "        }\n"
//            + "    }\n"
//            + "    ?le rdfs:label ?label .\n"
//            + "    ?leTarget rdfs:label ?labelTarget .\n"
//            + "    ?source skos:definition ?def .\n"
//            + "    ?target skos:definition ?defTarget .\n"
//            + "}";

//    public static final String GRAPH_VIZ_NODE_GRAPH_WITH_LENGHT
//            = SparqlPrefix.ONTOLEX.getSparqlPrefix() + "\n"
//            + SparqlPrefix.ONTO.getSparqlPrefix() + "\n"
//            + SparqlPrefix.LEXINFO.getSparqlPrefix() + "\n"
//            + SparqlPrefix.LEX.getSparqlPrefix() + "\n"
//            + SparqlPrefix.SKOS.getSparqlPrefix() + "\n"
//            + SparqlPrefix.RDFS.getSparqlPrefix() + "\n"
//            + "SELECT ?source ?label ?pos ?def ?labelTarget ?target ?posTarget ?defTarget (count(?mid) as ?lenght)\n"
//            + "            WHERE {\n"
//            + "               ?source lexinfo:_RELATION_* ?mid .\n"
//            + "                               ?mid lexinfo:_RELATION_ ?target  .\n"
//            + "                ?source skos:definition ?def .\n"
//            + "               ?le ontolex:sense ?source ;\n"
//            + "                   lexinfo:partOfSpeech ?pos ;\n"
//            + "                    rdfs:label ?label .\n"
//            + "                ?target skos:definition ?defTarget .\n"
//            + "                ?leTarget ontolex:sense ?target ;\n"
//            + "                       lexinfo:partOfSpeech ?posTarget ;\n"
//            + "                       rdfs:label ?labelTarget .\n"
//            + "                 VALUES (?source) { (<_NODE_ID_>) }\n"
//            + "            }\n"
//            + "GROUP BY ?target ?source ?label ?pos ?def ?labelTarget ?target ?posTarget ?defTarget\n"
//            + "ORDER BY ?lenght";
    public static final String GRAPH_VIZ_EDGE_GRAPH
            = SparqlPrefix.ONTOLEX.getSparqlPrefix() + "\n"
            + SparqlPrefix.ONTO.getSparqlPrefix() + "\n"
            + SparqlPrefix.LEXINFO.getSparqlPrefix() + "\n"
            + SparqlPrefix.LEX.getSparqlPrefix() + "\n"
            + SparqlPrefix.RDFS.getSparqlPrefix() + "\n"
            + "SELECT ?graph ?source ?target ?sourceLabel ?targetLabel ?relation\n"
            + "FROM NAMED onto:implicit\n"
            + "FROM NAMED onto:explicit\n"
            + "WHERE {\n"
            + "    GRAPH ?graph { ?source ?relation ?target .\n"
            + "        VALUES ?source { lex:_SOURCE_ } .\n"
            + "        VALUES ?target { lex:_TARGET_ } .\n"
            + "        VALUES ?relation { lexinfo:_RELATION_ } .\n"
            + "    }\n"
            + "    ?source ontolex:isSenseOf [ rdfs:label ?sourceLabel ] .\n"
            + "    ?target ontolex:isSenseOf [ rdfs:label ?targetLabel ] .\n"
            + "}";

    public static final String GRAPH_VIZ_HOPS_BY_REL
            = "PREFIX path: <http://www.ontotext.com/path#>\n"
            + "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n"
            + "PREFIX dbr: <http://dbpedia.org/resource/>\n"
            + "PREFIX lex: <http://lexica/mylexicon#>\n"
            + "PREFIX onto: <http://www.ontotext.com/>\n"
            + "PREFIX dct: <http://purl.org/dc/terms/modified>\n"
            + "PREFIX lexinfo: <http://www.lexinfo.net/ontology/3.0/lexinfo#>\n"
            + "PREFIX vartrans: <http://www.w3.org/ns/lemon/vartrans#>\n"
            + "\n"
            + "SELECT ?" + SparqlVariable.TYPE + " (COUNT(DISTINCT ?index) as ?" + SparqlVariable.LENGHT + ") (GROUP_CONCAT(?edge;separator=\";\") as ?" + SparqlVariable.HOPS + ")\n"
            + "#FROM onto:explicit\n"
            + "WHERE {\n"
            + "    VALUES (?_DIRECTION_ ?" + SparqlVariable.TYPE + ") {\n"
            + "        ( lex:_SOURCE_ \"_DIRECTIONVALUE_\" )\n"
            + "    }\n"
            + "    SERVICE <http://www.ontotext.com/path#search> {\n"
            + "        <urn:path> path:findPath path:allPaths ;\n"
            + "                   path:sourceNode ?src ;\n"
            + "                   path:destinationNode ?dst ;\n"
            + "                   path:pathIndex ?path ;\n"
            + "                   path:resultBinding ?edge ;\n"
            + "                   path:startNode ?source ;\n"
            + "                   path:endNode ?target ;\n"
            + "                   path:resultBindingIndex ?index .\n"
            + "        SERVICE <urn:path> {\n"
            + "            ?source lexinfo:_RELATION_ ?target\n"
            + "        }\n"
            + "   } \n"
            + "} GROUP BY ?path ?" + SparqlVariable.TYPE + " ORDER BY DESC(?" + SparqlVariable.LENGHT + ")";
}
